package usecases

import (
	"crypto/rand"
	"errors"
	"fmt"
	"strings"
	"time"

	"golang.org/x/crypto/bcrypt"

	"github.com/sj14/web-demo/domain"
)

func NewUserUsecases(userRepository userRepositoryInterface) UserUsecases {
	return UserUsecases{repository: userRepository}
}

type UserUsecases struct {
	repository userRepositoryInterface
}

type userRepositoryInterface interface {
	StoreUser(user domain.User) (userID int64, err error)
}

func (interactor *UserUsecases) CreateUser(name, email, passwordPlain string, zipCode int64) (id int64, err error) {

	// Verify Plain Password Complexity
	err = interactor.validatePasswordRules(passwordPlain)
	if err != nil {
		return -1, err
	}

	// Create hashed password
	passwordHash, err := interactor.hashPassword(passwordPlain)
	if err != nil {
		return -1, err
	}

	// Create email verification Token
	emailToken := randToken(100)

	// Create User Object
	userWithoutID := domain.User{
		ID:            0,
		Name:          name,
		Email:         email,
		PasswordHash:  passwordHash,
		IsDisabled:    false,
		EmailVerified: false,
		EmailToken:    emailToken,
		ZipCode:       zipCode,
		FailedLogins:  0,
		LastLogin:     time.Now(),
		CreatedAt:     time.Now(),
		UpdatedAt:     time.Now(),
	}

	// Verify User
	err = interactor.validateUserExceptPassword(userWithoutID)
	if err != nil {
		return -1, err
	}

	// Store User without autogenerated Id
	return interactor.repository.StoreUser(userWithoutID)
}

func (interactor *UserUsecases) validatePasswordRules(pw string) error {
	// Check if password is good
	if len(pw) < 8 {
		return errors.New("Password too short. Needs a length of min. 8 characters/symbols")
	}
	return nil
}

func (interactor *UserUsecases) validateUserExceptPassword(user domain.User) error {
	// Check if name and email is not empty
	if user.Name == "" || user.Email == "" {
		return errors.New("First name, last name, email can not be empty")
	}

	// Convert Email to lowercase characters
	user.Email = strings.ToLower(user.Email)

	// Check if email is already used
	// mailAlreadyUsedUserID, err := interactor.FindUserIdByEmail(user.Email)
	// if err == nil && mailAlreadyUsedUserId != user.Id {
	// 	// Email is in use by another user, otherwise there would be an error,
	// 	// that email was not found
	// 	return ErrEmailInUse
	// }

	return nil
}

func (interactor *UserUsecases) DeleteUser(id int64, executingUser domain.User) error {
	// if executingUser.Id == id || executingUser.HasAccessRole(domain.AccessRoleAdmin) {
	// 	err := interactor.repository.DeleteUserById(id)
	// 	return err
	// }
	return errors.New("Error Deleting User")
}

func (interactor *UserUsecases) hashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(bytes), err
}

func (interactor *UserUsecases) checkPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

func randToken(len uint) string {
	b := make([]byte, len)
	rand.Read(b)
	return fmt.Sprintf("%x", b)
}
