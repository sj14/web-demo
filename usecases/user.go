package usecases

import (
	"crypto/rand"
	"errors"
	"fmt"
	"strings"
	"time"

	"golang.org/x/crypto/bcrypt"

	"log"

	"github.com/sj14/web-demo/domain"
)

func NewUserUsecases(userRepository userRepositoryInterface) UserUsecases {
	return UserUsecases{repository: userRepository}
}

type UserUsecases struct {
	repository userRepositoryInterface
}

type userRepositoryInterface interface {
	StoreUser(user domain.User) (userID int64, err error)
	FindUserById(id int64) (domain.User, error)
	FindUserIdByEmail(email string) (userID int64, err error)
	UpdateUserExceptPassword(user domain.User) error
	UpdateUserPasswordOnly(userID int64, password string) error
}

// TODO: Validate mail address (is there an "@", etc.)
var ErrEmailInUse = errors.New("The mail address is already registered")

func (interactor *UserUsecases) CreateUser(name, email, passwordPlain string) (id int64, err error) {

	// Verify Plain Password Complexity
	err = interactor.validatePasswordRules(passwordPlain)
	if err != nil {
		return -1, err
	}

	// Create hashed password
	passwordHash, err := interactor.hashPassword(passwordPlain)
	if err != nil {
		return -1, err
	}

	// Create email verification Token
	emailToken := randToken(100)

	// Create User Object
	userWithoutID := domain.User{
		ID:            0,
		Name:          name,
		Email:         email,
		PasswordHash:  passwordHash,
		IsDisabled:    false,
		EmailVerified: false,
		EmailToken:    emailToken,
		FailedLogins:  0,
		LastLogin:     time.Now(),
		CreatedAt:     time.Now(),
		UpdatedAt:     time.Now(),
	}

	// Verify User
	err = interactor.validateUserExceptPassword(userWithoutID)
	if err != nil {
		return -1, err
	}

	// Store User without autogenerated Id
	return interactor.repository.StoreUser(userWithoutID)
}

func (interactor *UserUsecases) validatePasswordRules(pw string) error {
	// Check if password is good
	if len(pw) < 8 {
		return errors.New("Password too short. Needs a length of min. 8 characters/symbols")
	}
	return nil
}

func (interactor *UserUsecases) validateUserExceptPassword(user domain.User) error {
	// Check if name and email is not empty
	if user.Name == "" || user.Email == "" {
		return errors.New("First name, last name, email can not be empty")
	}

	// Convert Email to lowercase characters
	user.Email = strings.ToLower(user.Email)

	// Check if email is already used
	mailAlreadyUsedUserID, err := interactor.FindUserIdByEmail(user.Email)
	if err == nil && mailAlreadyUsedUserID != user.ID {
		// Email is in use by another user, otherwise there would be an error,
		// that email was not found
		return ErrEmailInUse
	}

	return nil
}

var ErrUserDisabled = errors.New("User is disabled")

func (interactor *UserUsecases) LoginUser(userId int64, passwordPlain string) (bool, error) {
	user, err := interactor.repository.FindUserById(userId)
	if err != nil {
		log.Println(err)
		return false, err
	}

	if user.IsDisabled {
		log.Println("User is disabled")
		return false, ErrUserDisabled
	}

	passwordHash := user.PasswordHash
	isMatch := interactor.checkPasswordHash(passwordPlain, passwordHash)
	if isMatch == false {
		log.Println("Incrementing Failed Login Attempts for userid: ", userId)
		//err := interactor.applicantRepo.IncrementFailedLoginAttempts(userId)

		user.FailedLogins += 1
		err := interactor.repository.UpdateUserExceptPassword(user)
		if err != nil {
			log.Println("Not able to increment failed login attempts for userid", userId)
		}

		return false, errors.New("Wrong usercontroller or password")
	} else {
		//err := interactor.applicantRepo.ResetFailedLoginAttempts(userId)
		user.FailedLogins = 0
		err := interactor.repository.UpdateUserExceptPassword(user)
		if err != nil {
			log.Println("Not able to reset login attempts for userid", userId, err)
		}
		//err = interactor.applicantRepo.SetLastLogin(userId)
		user.LastLogin = time.Now()
		err = interactor.repository.UpdateUserExceptPassword(user)
		if err != nil {
			log.Println("Not able to set last login time for userid", userId)
		}
	}
	return isMatch, nil
}

func (interactor *UserUsecases) DeleteUser(id int64, executingUser domain.User) error {
	// if executingUser.Id == id || executingUser.HasAccessRole(domain.AccessRoleAdmin) {
	// 	err := interactor.repository.DeleteUserById(id)
	// 	return err
	// }
	return errors.New("Error Deleting User")
}

func (interactor *UserUsecases) hashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(bytes), err
}

func (interactor *UserUsecases) checkPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

func randToken(len uint) string {
	b := make([]byte, len)
	rand.Read(b)
	return fmt.Sprintf("%x", b)
}

func (interactor *UserUsecases) UpdateUserExceptPassword(user domain.User) error {
	err := interactor.validateUserExceptPassword(user)
	if err != nil {
		return err
	}
	err = interactor.repository.UpdateUserExceptPassword(user)
	if err != nil {
		return err
	}
	return nil
}

var ErrPasswordNotMatch = errors.New("The password was not correct")

func (interactor *UserUsecases) UpdateUserPasswordOnly(userID int64, curPassPlain, newPassPlain string) error {
	user, err := interactor.FindUserById(userID)
	if err != nil {
		return err
	}

	// Check if the current password was correct
	if ok := interactor.checkPasswordHash(curPassPlain, user.PasswordHash); ok != true {
		return ErrPasswordNotMatch
	}

	err = interactor.validatePasswordRules(newPassPlain)
	if err != nil {
		return err
	}

	newPassHash, err := interactor.hashPassword(newPassPlain)
	if err != nil {
		return err
	}

	err = interactor.repository.UpdateUserPasswordOnly(userID, newPassHash)
	if err != nil {
		return err
	}
	return nil
}

func (interactor *UserUsecases) VerifyEmailAndActivateUser(userId int64, tokenFromUrl string) error {
	user, err := interactor.repository.FindUserById(userId)
	if err != nil {
		return err
	}

	if user.EmailToken != tokenFromUrl {
		return errors.New("Token does not match")
	}

	user.EmailVerified = true
	err = interactor.repository.UpdateUserExceptPassword(user)
	return err
}

func (interactor *UserUsecases) FindUserById(id int64) (domain.User, error) {
	user, err := interactor.repository.FindUserById(id)
	if err != nil {
		return domain.User{}, err
	}
	return user, nil
}

var ErrInvalidZipCode = errors.New("Invalid ZipCode length")

func (interactor *UserUsecases) FindUserIdByEmail(email string) (int64, error) {
	userId, err := interactor.repository.FindUserIdByEmail(email)
	if err != nil {
		return -1, err
	}
	return userId, nil
}
